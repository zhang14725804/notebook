## 从多线程到Event Loop全面梳理

### CPU、进程、线程之间的关系

- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 不同进程之间也可以通信，不过代价较大
- 单线程与多线程，都是指在一个进程内的单和多

### 浏览器是多进程的

- 浏览器是多进程的
- 每一个Tab页，就是一个独立的子进程

### 浏览器包含了那些进程

- 主进程

    + 协调控制其他子进程（创建、销毁）
    + 浏览器界面显示，用户交互，前进、后退、收藏
    + 将渲染进程得到的内存中的Bitmap，绘制到用户界面上
    + 处理不可见操作，网络请求，文件访问等

- 第三方插件进程

- GPU进程

- 渲染进程（浏览器内核）

### 浏览器内核/渲染进程 （多线程）

- 【GUI渲染线程】

- 【JS引擎线程】

- 【事件线程】

    + 用来控制事件循环（鼠标点击、setTimeout、ajax等）
    + 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中

- 定时器线程

- 【异步http线程】

### 为什么javascript是单线程的

- 历史原因

- 多线程复杂（需要加锁）

### 为什么【GUI渲染线程】和【JS引擎线程】互斥

由于js可以操作DOM，若同时修改元素并渲染界面（js线程和【GUI线程】同时运行），结果不可控

当【JS引擎线程】执行时【GUI渲染线程】会被挂起，GUI更新则会被保存在一个队列中等待【JS引擎线程】空闲时立即被执行。

### 从Event Loop看JS运行机制（什么是【执行栈】，什么是【事件队列】，重点！！！）

- JS分为同步任务和异步任务
- 同步任务都在【JS引擎线程】上执行，形成一个【执行栈】
- 【事件线程】管理一个【任务队列】，异步任务触发条件达成，将回调事件存入【任务队列】
- 【执行栈】中所有同步任务执行完毕，此时【js引擎线程】空闲，系统读取【任务队列】，将异步任务回调事件添加到【执行栈】中，开始执行

我们知道，不管是 setTimeout/setInterval和XHR/fetch 代码，在这些代码执行时，本身是同步任务，而其中的回调函数才是异步任务。

当代码执行到setTimeout/setInterval时，实际上是【JS引擎线程】通知定时器线程，间隔一个时间后，会触发一个回调事件，而定时器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由【事件线程】所管理的【事件队列】中。

当代码执行到XHR/fetch时，实际上是【JS引擎线程】通知【异步http线程】，发送一个网络请求，并制定请求完成后的回调事件，而【异步http线程】在接收到这个消息后，会在请求成功后，将回调事件放入到由【事件线程】所管理的【事件队列】中。

当我们的同步任务执行完，【JS引擎线程】会询问【事件线程】，在【事件队列】中是否有待执行的回调函数，如果有就会加入到【执行栈】中交给【JS引擎线程】执行

```javascript
let timerCallback = function() {
  console.log('wait one second');
};
let httpCallback = function() {
  console.log('get server data success');
}

// 同步任务
console.log('hello');
// 同步任务
// 通知定时器线程 1s 后将 timerCallback 交由【事件线程】处理
// 1s 后【事件线程】将 timerCallback 加入到【事件队列】中
setTimeout(timerCallback,1000);
// 同步任务
// 通知【异步http线程】发送网络请求，请求成功后将 httpCallback 交由【事件线程】处理
// 请求成功后【事件线程】将 httpCallback 加入到【事件队列】中
$.get('www.xxxx.com',httpCallback);
// 同步任务
console.log('world');
//...
// 所有同步任务执行完后
// 询问【事件线程】在事件【事件队列】中是否有需要执行的回调函数
// 如果没有，一直询问，直到有为止
// 如果有，将回调事件加入【执行栈】中，开始执行回调代码

```

- 【JS引擎线程】只执行【执行栈】中的事件
- 【执行栈】中的代码执行完毕，就会读取【事件队列】中的事件
- 【事件队列】中的回调事件，是由各自线程插入到【事件队列】中的
- 如此循环


### 【宏任务】、【微任务】

- 【宏任务】

我们可以将每次【执行栈】执行的代码当做是一个【宏任务】（包括每次从【事件队列】中获取一个事件回调并放到【执行栈】中执行），每一个【宏任务】会从头到尾执行完毕，不会执行其他。

【JS引擎线程】和【GUI渲染线程】是互斥的关系，浏览器为了能够使【宏任务】和DOM任务有序的进行，会在一个【宏任务】执行结果后，在下一个【宏任务】执行前，【GUI渲染线程】开始工作，对页面进行渲染。

主代码块，setTimeout，setInterval等，都属于【宏任务】

```javascript
document.body.style = 'background:black';
document.body.style = 'background:red';
document.body.style = 'background:blue';
document.body.style = 'background:grey';
```
页面背景会在瞬间变成灰色，以上代码属于同一次【宏任务】，所以全部执行完才触发页面渲染，渲染时【GUI线程】会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。

```javascript
document.body.style = 'background:blue';
setTimeout(function(){
    document.body.style = 'background:black'
},0)
```
页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次【宏任务】，第一次【宏任务】执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次【宏任务】将背景变成黑色。

- 【微任务】

【宏任务】结束后，会执行渲染，然后执行下一个【宏任务】， 而【微任务】可以理解成在当前【宏任务】执行后立即执行的任务。

也就是说，当【宏任务】执行完，会在渲染前，将执行期间所产生的所有【微任务】都执行完。

Promise，process.nextTick等，属于【微任务】。
```javascript
document.body.style = 'background:blue'
console.log(1);
Promise.resolve().then(()=>{
    console.log(2);
    document.body.style = 'background:black'
});
console.log(3);
```
控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出

页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在【宏任务】中将背景设置为蓝色，但在进行渲染前执行了【微任务】，在【微任务】中将背景变成了黑色，然后才执行的渲染
```javascript
setTimeout(() => {
    console.log(1)
    Promise.resolve(3).then(data => console.log(data))
}, 0)

setTimeout(() => {
    console.log(2)
}, 0)

// print : 1 3 2
```
上面代码共包含两个 setTimeout ，也就是说除主代码块外，共有两个【宏任务】，
其中第一个【宏任务】执行中，输出 1 ，并且创建了【微【任务队列】】，所以在下一个【宏任务】队列执行前，
先执行【微任务】，在【微任务】执行中，输出 3 ，【微任务】执行后，执行下一次【宏任务】，执行中输出 2


- 总结

    + 执行一个【宏任务】（栈中没有就从【事件队列】中获取）
    + 执行过程中如果遇到【微任务】，就将它添加到【微任务】的【任务队列】中
    + 【宏任务】执行完毕后，立即执行当前【微【任务队列】】中的所有【微任务】（依次执行）
    + 当前【宏任务】执行完毕，开始检查渲染，然后【GUI线程】接管渲染
    + 渲染完毕后，JS线程继续接管，开始下一个【宏任务】（从【事件队列】中获取）




参考:[进程，线程，event-loop](https://juejin.im/post/5d5b4c2df265da03dd3d73e5)

