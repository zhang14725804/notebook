## 微服务可用性设计

    隔离
    超时控制
    过载保护
    限流
    降级
    重试
    负载均衡
    最佳实践

微服务问题：可用性问题、数据一致性问题

【SOP——标准操作流程】

## 隔离

保证发生故障时能限定传播范围和影响范围，让影响面变得更小

    服务隔离：动静隔离（CDN + 边缘计算）、读写隔离（主从、【CQRS】、replicaset）
    轻重隔离：核心（业务按照level进行资源划分）、快慢、热点（主动预热，被动预热）
    物理隔离：线程（tomcat线程池线程耗尽 fail fast）、进程（k8s）、集群（region.zone.cluster.appid）、机房

读写分离的文章：https://zhuanlan.zhihu.com/p/138884686

【多活架构】、【false sharing 伪共享】

同一张表同一行的数据，【经常修改的字段】和不怎么修改的字段可以分表：稿件表，稿件统计表

对于GO，所有IO都是Nonblocking，且托管给了runtime，只会阻塞Goroutine，不阻塞M，只考虑goroutine总量的控制，不需要考虑线程和线程隔离。

java除了【线程池】隔离，也有基于【信号量】的做法

### 隔离case

1. 转码集群被大视频攻击，导致转码大量延迟。根据视频大小（大，中，小）分多套处理服务

2. 入口Nginx故障，影响全机房流量入口。

3. 缩略图服务，被大图实时缩略耗光所有CPU，导致正常范围小缩略图被丢弃，大量503

4. MySQL实例【cgroup】未隔离，导致大SQL引起的集体故障

5. INFO日质量过大，导致异常ERROR日志采集延迟

【chroot namespace隔离】

播放器【硬解码】和【软解码】

## 超时控制

本质上是【快速失效 fail fast】

【连接超时，写超时，读超时】

服务器挂了如何做超时控制：（1）心跳检测（2）keep-alive 超时之后发icmp请求给服务器，检测是否正常

超时传递：进程间传递+跨进程传递

【SRE重要理念之SLA、SLO、SLI】

各服务之间超时时间发生变化该如何处理？核心就是有地方记录超时时间，形成君子约定

【进程内超时控制怎么做？】【进程间超时传递怎么做？gRPC】




