## 工程化（尽量看官方文档）

    （1）工程项目结构（代码如何组织、分层、目录命名；代码资源初始化，依赖注入怎么做）
    （2）API设计（Grpc、HTTP；API传输和服务实现隔离，可以同时生成Grpc和HTTP代码）
    （3）配置管理（管理、生成、定义，方便的加载并初始化，和struct类交互）
    （4）包管理
    （5）测试（API、dao、service如何测试，单元测试）


## 工程项目结构（😅😅😅 ）

### Standard Go Project Layout

https://github.com/golang-standards/project-layout

【Package Oriented Design】


    /cmd 项目主干 需要再加一层和当前项目名匹配 /cmd/myApp
    /internal 私有应用程序和库代码，不希望其他人在其他应用程序或库中导入的代码 /internal/myApp
    /pkg 外部应用程序可以使用的代码库，按照功能分类
    /kit 配套工具包基础库；统一、高度抽象、支持插件

pkg和internal的区别

### Service Application Project Layout

    /api（公司级api权限问题）
    /configs 配置文件（yarm,ini）
    /test
    /src 不应该包含src目录


### Service Application Project

一个gitlab的project里可以放置多个微服务的app。按照gitlab的group里建立多个project，每个project对应一个app

    多 app 的方式，app 目录内的每个微服务按照自己的全局唯一名称，比如 “account.service.vip” 来建立目录，如: account/vip/*

微服务中的app服务分为4类：interface、service、job（常驻任务）、task（定时任务）、admin（面向运营侧）

**cmd应用目录负责程序的：启动、关闭、配置初始化**

### Service Application Project-v1（存在些什么问题）

【dao、service、model三层架构，也叫分层架构，按照功能组织】、【DDD领域驱动设计】

【失血模型,贫血模型,充血模型,胀血模型】

    /api
    /cmd
    /configs
    /internal/(model,dao,service,server（server层可以被干掉）)


**dao层处理【数据库和缓存包括cache missing处理】逻辑**



### Service Application Project-v2

https://github.com/ent/ent


DTO（数据传输对象）: 用来做api传输。DO（领域对象，业务对象）。PO（持久化对象）

service层：DTO -> DO

    /internal/(service,biz,data,pkg)


【依赖倒置原则DIP 😅】

【控制反转的一种实现——依赖注入 😅】：方便测试，单次初始化和复用

### Wire

【Lifecycle声明周期管理】：启动，失败释放资源，关闭

https://blog.golang.org/wire：资源的初始化和关闭


## API设计



