## 解 B+ 树存储引擎（InnoDB、BoltDB、BuntDB）

    1.数据存储与检索背景
    2.基于页结构的存储引擎
    3.基于日志结构的存储引擎


## 1. 数据存储与检索背景

【OLTP（在线事务处理）】、【OLAP（在线分数处理）】两大类

OLAP：hive，spark，hbase

OLTP分类：面向页（B+ tree）、日志结构（Ism tree）

解决了什么问题？怎么解决的？

### 为什么选择B+树

读多写少场景，数据按行组织，存储数据量级

访问速度：磁盘随机IO << 磁盘顺序IO ～～ 内存随机IO  << 内存顺序IO

    磁盘如何快速读写：顺序IO
    每条数据顺序追加后怎么读：每条记录维护一个索引
    如何支持排序，范围查询：
    千万条记录需要维护千万条索引，怎么办
    找到合适存储索引项的数据结构，亚索、优化存储索引
    减少或合理组织需要维护的索引项

之所以每条记录都需要维护一个【索引项】的根本原因是：每条记录都是变长的，长度是不固定的（有点类似内存管理，分段分页的思想？） （索引项如何解决长度不固定的问题？）

【磁盘块信息+磁盘块内信息】唯一确定一条信息

    变长：每条记录长度不固定。
    定长：磁盘划分成固定大小块。
    （1）引入块后如何读写（每个磁盘块维护两个信息：当前第几块，保存数据的范围）
    （2）块大小怎么定。（让OS以块为单位读写（页大小4K为基准））
    （3）快索引存不存，怎么存（根据是否将数据和索引分开分成：聚簇索引，非聚簇索引）


**【B树还是B+树】、各种树的演变 😅😅😅**

### B+树能存储多少条数据，如何粗略计算（数量级粗略估算）

以高度为3、4的B+树，innodb一页为【16K】为例。假设叶子节点每行数据大小160byte，则一页可以存100条数据，非叶子节点假设每条信息16byte，则一页能存1000条元素。

    对于3层B+树：1000*1000*100
    对于4层B+树：1000*1000*1000*100
    



### 基于页的B+树存储引擎【解决了哪些问题】？

【内存和磁盘如何映射、如何写入、如何读取】


### 读写流程的边界、异常问题（innodb、boltdb、buntdb三种引擎的处理方式 😅😅😅）

    （1）插入更新数据过大、过小问题
    （2）删除一条记录，会发生什么（不合并，向前合并，向后合并）
    （3）数据写入内存，没来得及写入磁盘
    （4）数据写入内存，部分写入磁盘
    （5）数据写入内存，写入磁盘时，磁盘满了


### 存储引擎特性：事务、全表扫描

innodb、boltdb、buntdb实现方式

事务如何保证【ACID】，事务难点（读写事务，写写事务，读读事务），事务边界问题


### 基于B+树存储引擎源码分析

【自底向上分析boltDB源码】