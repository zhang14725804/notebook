## TCP三次握手和四次挥手

    请画出三次握手和四次挥手的示意图
    为什么连接的时候是三次握手？
    什么是半连接队列？
    ISN(Initial Sequence Number)是固定的吗？
    三次握手过程中可以携带数据吗？
    如果第三次握手丢失了，客户端服务端会如何处理？
    SYN攻击是什么？
    挥手为什么需要四次？
    四次挥手释放连接时，等待2MSL的意义?

## 三次握手

### 1.为什么要三次而不是两次

进行三次握手的主要作用就是为了【确认双方的接收能力和发送能力】是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换【TCP窗口大小】信息。客户端和服务端通信前要进行连接，“3次握手”的作用就是【双方都能明确自己和对方的收、发能力是正常的】。

- 第一次握手

客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 【SYN_SEND】 状态。这样【服务端】就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

- 第二次握手

服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 【SYN_RCVD】 的状态。这样【客户端】就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。

- 第三次握手
客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 【ESTABLISHED】 状态。服务器收到 ACK 报文之后，也处于 【ESTABLISHED】 状态，此时，双方已建立起了连接。这样【服务端】就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。

### 2.半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为【半连接队列】。
当然还有一个【全连接队列】，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### 3.ISN(Initial Sequence Number)

【按序列号组装数据】。当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 4.三次握手过程中可以携带数据吗？第三次可以，第一第二次不可以

第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

### 5.SYN攻击是什么

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的。

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

常见的防御 SYN 攻击的方法有如下几种：

    缩短超时（SYN Timeout）时间
    增加最大半连接数
    过滤网关防护
    SYN cookies技术

### 6.TCP三次握手第三次握手时ACK丢失怎么办

如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。

Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。

但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包(用于强制关闭tcp连接)响应，方能感知到Server的错误。

## 四次挥手

### 1.为什么挥手需要四次

接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。

这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

- 第一次挥手

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 【FIN_WAIT1】 状态。 即发出连接释放报文段

- 第二次挥手

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文。表明已经收到客户端的报文了，此时服务端处于 【CLOSE_WAIT】 状态。 即服务端收到连接释放报文段后即发出确认报文段

- 第三次挥手

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 【LAST_ACK】 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段

- 第四次挥手

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 【TIME_WAIT】 状态

### 2. 四次挥手释放连接时，等待2MSL的意义。2MSL等待状态（ 😅 ）

### 参考：

[“三次握手，四次挥手”你真的懂吗？](https://zhuanlan.zhihu.com/p/53374516)

[不要再问我三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-7)

[图解TCP-小林coding](https://www.cnblogs.com/xiaolincoding/p/12638546.html)

[大白话TCP](https://github.com/jawil/blog/issues/14)