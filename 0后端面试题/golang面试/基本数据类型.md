### 1. golang对nil的slice和空slice处理是否一致。【零切片】、【空切片】和【nil 切片】

- 切片数据结构

        type slice struct {
            array unsafe.Pointer
            length int
            capcity int
        }

- 【零切片】

        var s = make([]int, 10)
        fmt.Println(s)
        var s = make([]*int, 10)
        fmt.Println(s)

- 【空切片】。所有类型的「空切片」都共享这一个内存地址

        var emptySlice = []int{}
        var emptySlice = make([]int, 0)

- 【nil切片】
        
        var nilSlice []int
        var nilSlice = *new([]int)


- 空切片和nil切片区别
```golang
        var s1 []int
        var s2 = []int{}

        fmt.Println(s1 == nil) // true
        fmt.Println(s2 == nil) // false

        fmt.Printf("%#v\n", s1) // []int(nil)
        fmt.Printf("%#v\n", s2) // []int{}

        // 「空切片」和「 nil 切片」还有一个极为不同的地方在于 JSON 序列化
        type Something struct {
            Values []int
        }

        var s1 = Something{}
        var s2 = Something{[]int{}}
        bs1, _ := json.Marshal(s1)
        bs2, _ := json.Marshal(s2)
        fmt.Println(string(bs1)) // {"Values":null}
        fmt.Println(string(bs2)) // {"Values":[]}
```

### 2.golang struct能否比较

    同一个struct的两个实例能不能比较？
    两个不同的struct的实例能不能比较？

（1） 同一个struct的两个实例能不能比较

golang中，哪些数据类型是可比较的，哪些是不可比较的：

    可比较：Integer，Floating-point，String，Boolean，Complex(复数型)，Pointer，Channel，Interface，Array
    不可比较：Slice，Map，Function

- 当结构不包含不可直接比较成员变量时可直接比较，否则不可直接比较

- 当我们需要对含有不可直接比较的数据类型的结构体实例进行比较时，可以借助 【reflect.DeepEqual】 函数

- reflect.DeepEqual 是如何对变量进行比较的呢？

（2）两个不同的struct的实例能不能比较

- 可通过强制转换来比较
- 如果成员变量中含有不可比较成员变量，即使可以强制转换，也不可以比较

（3） struct可以作为map的key么

struct必须是可比较的，才能作为key，否则编译时报错




### go合法常量

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型

### 引用类型和值类型

- 值类型（无法添加方法，起别名可以。为啥😅 😅 😅）

【数组】。【string】是值类型

- 引用类型（是否赋值为nil）：

    map
    func
    chan
    slice切片。但数组是值类型
    pointer指针


```golang
var x1 = nil // wrong
var x2 interface{} = nil
var x3 string = nil // wrong
var x4 error = nil
```

### 堆（heap），栈（stack）的区别和联系（😅 😅 😅 ）

### 遍历map问题

```golang
m := make(map[string]*Student)
stus := []Student{
    {Name: "zhao", Age: 23},
    {Name: "qian", Age: 23},
    {Name: "sun", Age: 23},
}
// 全都取到相同的地址：map[qian:0xc0000044c0 sun:0xc0000044c0 zhao:0xc0000044c0]
// for _, v := range stus {
// 	m[v.Name] = &v
// }
// map[qian:0xc000042068 sun:0xc000042080 zhao:0xc000042050]
for i := 0; i < len(stus); i++ {
    m[stus[i].Name] = &stus[i]
}
Println(m)
```


### slice初始化问题

```golang
s := make([]int, 5)
s = append(s, 1, 2, 3)
// [0 0 0 0 0 1 2 3]
Println(s)
```

