### 1. golang对nil的slice和空slice处理是否一致。【零切片】、【空切片】和【nil 切片】

- 切片数据结构

        type slice struct {
            array unsafe.Pointer
            length int
            capcity int
        }

- 【零切片】

        var s = make([]int, 10)
        fmt.Println(s)
        var s = make([]*int, 10)
        fmt.Println(s)

- 【空切片】。所有类型的「空切片」都共享这一个内存地址

        var emptySlice = []int{}
        var emptySlice = make([]int, 0)

- 【nil切片】
        
        var nilSlice []int
        var nilSlice = *new([]int)


- 空切片和nil切片区别
```golang
        var s1 []int
        var s2 = []int{}

        fmt.Println(s1 == nil) // true
        fmt.Println(s2 == nil) // false

        fmt.Printf("%#v\n", s1) // []int(nil)
        fmt.Printf("%#v\n", s2) // []int{}

        // 「空切片」和「 nil 切片」还有一个极为不同的地方在于 JSON 序列化
        type Something struct {
            Values []int
        }

        var s1 = Something{}
        var s2 = Something{[]int{}}
        bs1, _ := json.Marshal(s1)
        bs2, _ := json.Marshal(s2)
        fmt.Println(string(bs1)) // {"Values":null}
        fmt.Println(string(bs2)) // {"Values":[]}
```

### 2.golang struct能否比较

    同一个struct的两个实例能不能比较？
    两个不同的struct的实例能不能比较？

（1） 同一个struct的两个实例能不能比较

golang中，哪些数据类型是可比较的，哪些是不可比较的：

    可比较：Integer，Floating-point，String，Boolean，Complex(复数型)，Pointer，Channel，Interface，Array
    不可比较：Slice，Map，Function

- 当结构不包含不可直接比较成员变量时可直接比较，否则不可直接比较

- 当我们需要对含有不可直接比较的数据类型的结构体实例进行比较时，可以借助 【reflect.DeepEqual】 函数

- reflect.DeepEqual 是如何对变量进行比较的呢？

（2）两个不同的struct的实例能不能比较

- 可通过强制转换来比较
- 如果成员变量中含有不可比较成员变量，即使可以强制转换，也不可以比较

（3） struct可以作为map的key么

struct必须是可比较的，才能作为key，否则编译时报错


### 3.go的defer原理（😅 难啃）

- 后调用的 defer 函数会先执行
- 函数的参数会被预先计算

```golang
func main() {
	for i := 0; i < 5; i++ {
		defer fmt.Println(i) // 4 3 2 1 0
	}
}
// defer 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用
func main() {
    {
        defer fmt.Println("defer runs")
        fmt.Println("block ends")
    }
    
    fmt.Println("main ends")
}
// result：
// block ends
// main ends
// defer runs

// Go 语言中所有的函数调用都是传值的，虽然 defer 是关键字，但是也继承了这个特性
func main() {
	startedAt := time.Now()
	defer fmt.Println(time.Since(startedAt))
	
	time.Sleep(time.Second)
}

// 虽然调用 defer 关键字时也使用值传递，但是因为拷贝的是函数指针
func main() {
	startedAt := time.Now()
	defer func() { fmt.Println(time.Since(startedAt)) }()
	
	time.Sleep(time.Second)
}
```

### go合法常量

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型

### 引用类型和值类型

引用类型（是否赋值为nil）：

    map
    func
    chan
    slice切片。但数组是值类型
    pointer指针


```golang
var x1 = nil // wrong
var x2 interface{} = nil
var x3 string = nil // wrong
var x4 error = nil
```

### 堆（heap），栈（stack）的区别和联系（😅 😅 😅 ）

### 


