### 1. golang对nil的slice和空slice处理是否一致。【零切片】、【空切片】和【nil 切片】

- 切片数据结构

        type slice struct {
            array unsafe.Pointer
            length int
            capcity int
        }

- 【零切片】

        var s = make([]int, 10)
        fmt.Println(s)
        var s = make([]*int, 10)
        fmt.Println(s)

- 【空切片】。所有类型的「空切片」都共享这一个内存地址

        var emptySlice = []int{}
        var emptySlice = make([]int, 0)

- 【nil切片】
        
        var nilSlice []int
        var nilSlice = *new([]int)


- 空切片和nil切片区别
```golang
        var s1 []int
        var s2 = []int{}

        fmt.Println(s1 == nil) // true
        fmt.Println(s2 == nil) // false

        fmt.Printf("%#v\n", s1) // []int(nil)
        fmt.Printf("%#v\n", s2) // []int{}

        // 「空切片」和「 nil 切片」还有一个极为不同的地方在于 JSON 序列化
        type Something struct {
            Values []int
        }

        var s1 = Something{}
        var s2 = Something{[]int{}}
        bs1, _ := json.Marshal(s1)
        bs2, _ := json.Marshal(s2)
        fmt.Println(string(bs1)) // {"Values":null}
        fmt.Println(string(bs2)) // {"Values":[]}
```

### 2.golang struct能否比较

    同一个struct的两个实例能不能比较？
    两个不同的struct的实例能不能比较？

（1） 同一个struct的两个实例能不能比较

golang中，哪些数据类型是可比较的，哪些是不可比较的：

    可比较：Integer，Floating-point，String，Boolean，Complex(复数型)，Pointer，Channel，Interface，Array
    不可比较：Slice，Map，Function

- 当结构不包含不可直接比较成员变量时可直接比较，否则不可直接比较

- 当我们需要对含有不可直接比较的数据类型的结构体实例进行比较时，可以借助 【reflect.DeepEqual】 函数

- reflect.DeepEqual 是如何对变量进行比较的呢？

（2）两个不同的struct的实例能不能比较

- 可通过强制转换来比较
- 如果成员变量中含有不可比较成员变量，即使可以强制转换，也不可以比较

（3） struct可以作为map的key么

struct必须是可比较的，才能作为key，否则编译时报错

```golang
func main() {
	sn1 := struct {
		age  int
		name string
	}{age: 11, name: "qq"}

	sn2 := struct {
		age  int
		name string
	}{age: 11, name: "qq"}
	// 🔥🔥🔥 结构体比较，比较属性的顺序和值。属性中包含不能比较的类型，结构体不可比较
	if sn1 == sn2 {
		Println("sn1== sn2")
	}
	sm1 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{"a": "1"}}
	sm2 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{"a": "1"}}
	if sm1 == sm2 {
		Println("sm1== sm2")
	}
}
```


### go合法常量

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型

### 引用类型和值类型

- 值类型（无法添加方法，起别名可以。为啥😅 😅 😅）

【数组】。【string】是值类型

- 引用类型（是否赋值为nil）：

    map
    func
    chan
    slice切片。但数组是值类型
    pointer指针


```golang
var x1 = nil // wrong
var x2 interface{} = nil
var x3 string = nil // wrong
var x4 error = nil
```

### 堆（heap），栈（stack）的区别和联系（😅 😅 😅 ）

### 遍历map问题

```golang
m := make(map[string]*Student)
stus := []Student{
    {Name: "zhao", Age: 23},
    {Name: "qian", Age: 23},
    {Name: "sun", Age: 23},
}
// 全都取到相同的地址：map[qian:0xc0000044c0 sun:0xc0000044c0 zhao:0xc0000044c0]
// for _, v := range stus {
// 	m[v.Name] = &v
// }
// map[qian:0xc000042068 sun:0xc000042080 zhao:0xc000042050]
for i := 0; i < len(stus); i++ {
    m[stus[i].Name] = &stus[i]
}
Println(m)
```


### slice初始化问题

```golang
s := make([]int, 5)
s = append(s, 1, 2, 3)
// [0 0 0 0 0 1 2 3]
Println(s)
```

### new切片返回指针

```golang
s := new([]int)
// first argument to append must be slice; have *[]int
s = append(s, 1)
Println(s)
```

### iota用法

```golang
const (
	x = iota
	y
	z = "zz"
	k
	p = iota
)

func main() {
	// 0 1 zz zz 4
	Println(x, y, z, k, p)
}
```

### 常量不允许修改，也不允许取地址
```golang
const cl = 100

var bl = 123

func main() {
	Println(&bl, bl)
	// cannot take the address of cl
	Println(&cl, cl)
}
```

### 类型别名和类型
```golang
type MyInt1 int
type MyInt2 = int // 😅 MyInt2就是int类型
var i int = 9
// cannot use i (type int) as type MyInt1 in assignment
var i1 MyInt1 = i
var i2 MyInt2 = i
Println(i1, i2)
```

### 变量作用域

```golang
var ErrDidNotWork = errors.New("did not work")

func DoTheThing(reallyDoIt bool) (err error) {
	// 因为 if 语句块内的 err 变量会遮罩函数作用域内的 err 变量
	if reallyDoIt {
		result, err := tryTheThing()
		if err != nil || result != "it worked" {
			err = ErrDidNotWork
		}
	}
	return err
}
func tryTheThing() (string, error) {
	return "", ErrDidNotWork
}
func main() {
	// 返回 nil
	Println(DoTheThing(true))
	Println(DoTheThing(false))
}
```

### 闭包延迟求值

```golang
func test() []func() {
	var funs []func()
	for i := 0; i < 2; i++ {
		funs = append(funs, func() {
			Println(&i, i)
		})
	}
	return funs
}

func main() {
    funs := test()
    // 0xc0000140a0 2
    // 0xc0000140a0 2
	for _, f := range funs {
		f()
	}
}
// 解决闭包延迟求值问题
func test() []func() {
	var funs []func()
	for i := 0; i < 2; i++ {
		x := i
		funs = append(funs, func() {
			Println(&x, x)
		})
	}
	return funs
}
```

```golang
func test(x int) (func(), func()) {
	return func() {
			Println(x)
			x += 10
		}, func() {
			Println(x)
		}
}
func main() {
	a, b := test(100)
	a() // 100
	b() // 110
}
```