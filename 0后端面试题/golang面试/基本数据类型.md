### 1. golangå¯¹nilçš„sliceå’Œç©ºsliceå¤„ç†æ˜¯å¦ä¸€è‡´ã€‚ã€é›¶åˆ‡ç‰‡ã€‘ã€ã€ç©ºåˆ‡ç‰‡ã€‘å’Œã€nil åˆ‡ç‰‡ã€‘

- åˆ‡ç‰‡æ•°æ®ç»“æ„

        type slice struct {
            array unsafe.Pointer
            length int
            capcity int
        }

- ã€é›¶åˆ‡ç‰‡ã€‘

        var s = make([]int, 10)
        fmt.Println(s)
        var s = make([]*int, 10)
        fmt.Println(s)

- ã€ç©ºåˆ‡ç‰‡ã€‘ã€‚æ‰€æœ‰ç±»å‹çš„ã€Œç©ºåˆ‡ç‰‡ã€éƒ½å…±äº«è¿™ä¸€ä¸ªå†…å­˜åœ°å€

        var emptySlice = []int{}
        var emptySlice = make([]int, 0)

- ã€nilåˆ‡ç‰‡ã€‘
        
        var nilSlice []int
        var nilSlice = *new([]int)


- ç©ºåˆ‡ç‰‡å’Œnilåˆ‡ç‰‡åŒºåˆ«
```golang
        var s1 []int
        var s2 = []int{}

        fmt.Println(s1 == nil) // true
        fmt.Println(s2 == nil) // false

        fmt.Printf("%#v\n", s1) // []int(nil)
        fmt.Printf("%#v\n", s2) // []int{}

        // ã€Œç©ºåˆ‡ç‰‡ã€å’Œã€Œ nil åˆ‡ç‰‡ã€è¿˜æœ‰ä¸€ä¸ªæä¸ºä¸åŒçš„åœ°æ–¹åœ¨äº JSON åºåˆ—åŒ–
        type Something struct {
            Values []int
        }

        var s1 = Something{}
        var s2 = Something{[]int{}}
        bs1, _ := json.Marshal(s1)
        bs2, _ := json.Marshal(s2)
        fmt.Println(string(bs1)) // {"Values":null}
        fmt.Println(string(bs2)) // {"Values":[]}
```

### 2.golang structèƒ½å¦æ¯”è¾ƒ

    åŒä¸€ä¸ªstructçš„ä¸¤ä¸ªå®ä¾‹èƒ½ä¸èƒ½æ¯”è¾ƒï¼Ÿ
    ä¸¤ä¸ªä¸åŒçš„structçš„å®ä¾‹èƒ½ä¸èƒ½æ¯”è¾ƒï¼Ÿ

ï¼ˆ1ï¼‰ åŒä¸€ä¸ªstructçš„ä¸¤ä¸ªå®ä¾‹èƒ½ä¸èƒ½æ¯”è¾ƒ

golangä¸­ï¼Œå“ªäº›æ•°æ®ç±»å‹æ˜¯å¯æ¯”è¾ƒçš„ï¼Œå“ªäº›æ˜¯ä¸å¯æ¯”è¾ƒçš„ï¼š

    å¯æ¯”è¾ƒï¼šIntegerï¼ŒFloating-pointï¼ŒStringï¼ŒBooleanï¼ŒComplex(å¤æ•°å‹)ï¼ŒPointerï¼ŒChannelï¼ŒInterfaceï¼ŒArray
    ä¸å¯æ¯”è¾ƒï¼šSliceï¼ŒMapï¼ŒFunction

- å½“ç»“æ„ä¸åŒ…å«ä¸å¯ç›´æ¥æ¯”è¾ƒæˆå‘˜å˜é‡æ—¶å¯ç›´æ¥æ¯”è¾ƒï¼Œå¦åˆ™ä¸å¯ç›´æ¥æ¯”è¾ƒ

- å½“æˆ‘ä»¬éœ€è¦å¯¹å«æœ‰ä¸å¯ç›´æ¥æ¯”è¾ƒçš„æ•°æ®ç±»å‹çš„ç»“æ„ä½“å®ä¾‹è¿›è¡Œæ¯”è¾ƒæ—¶ï¼Œå¯ä»¥å€ŸåŠ© ã€reflect.DeepEqualã€‘ å‡½æ•°

- reflect.DeepEqual æ˜¯å¦‚ä½•å¯¹å˜é‡è¿›è¡Œæ¯”è¾ƒçš„å‘¢ï¼Ÿ

ï¼ˆ2ï¼‰ä¸¤ä¸ªä¸åŒçš„structçš„å®ä¾‹èƒ½ä¸èƒ½æ¯”è¾ƒ

- å¯é€šè¿‡å¼ºåˆ¶è½¬æ¢æ¥æ¯”è¾ƒ
- å¦‚æœæˆå‘˜å˜é‡ä¸­å«æœ‰ä¸å¯æ¯”è¾ƒæˆå‘˜å˜é‡ï¼Œå³ä½¿å¯ä»¥å¼ºåˆ¶è½¬æ¢ï¼Œä¹Ÿä¸å¯ä»¥æ¯”è¾ƒ

ï¼ˆ3ï¼‰ structå¯ä»¥ä½œä¸ºmapçš„keyä¹ˆ

structå¿…é¡»æ˜¯å¯æ¯”è¾ƒçš„ï¼Œæ‰èƒ½ä½œä¸ºkeyï¼Œå¦åˆ™ç¼–è¯‘æ—¶æŠ¥é”™

```golang
func main() {
	sn1 := struct {
		age  int
		name string
	}{age: 11, name: "qq"}

	sn2 := struct {
		age  int
		name string
	}{age: 11, name: "qq"}
	// ğŸ”¥ğŸ”¥ğŸ”¥ ç»“æ„ä½“æ¯”è¾ƒï¼Œæ¯”è¾ƒå±æ€§çš„é¡ºåºå’Œå€¼ã€‚å±æ€§ä¸­åŒ…å«ä¸èƒ½æ¯”è¾ƒçš„ç±»å‹ï¼Œç»“æ„ä½“ä¸å¯æ¯”è¾ƒ
	if sn1 == sn2 {
		Println("sn1== sn2")
	}
	sm1 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{"a": "1"}}
	sm2 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{"a": "1"}}
	if sm1 == sm2 {
		Println("sm1== sm2")
	}
}
```


### goåˆæ³•å¸¸é‡

å¸¸é‡ä¸­çš„æ•°æ®ç±»å‹åªå¯ä»¥æ˜¯å¸ƒå°”å‹ã€æ•°å­—å‹ï¼ˆæ•´æ•°å‹ã€æµ®ç‚¹å‹å’Œå¤æ•°ï¼‰å’Œå­—ç¬¦ä¸²å‹

### å¼•ç”¨ç±»å‹å’Œå€¼ç±»å‹

- å€¼ç±»å‹ï¼ˆæ— æ³•æ·»åŠ æ–¹æ³•ï¼Œèµ·åˆ«åå¯ä»¥ã€‚ä¸ºå•¥ğŸ˜… ğŸ˜… ğŸ˜…ï¼‰

ã€æ•°ç»„ã€‘ã€‚ã€stringã€‘æ˜¯å€¼ç±»å‹

- å¼•ç”¨ç±»å‹ï¼ˆæ˜¯å¦èµ‹å€¼ä¸ºnilï¼‰ï¼š

    map
    func
    chan
    sliceåˆ‡ç‰‡ã€‚ä½†æ•°ç»„æ˜¯å€¼ç±»å‹
    pointeræŒ‡é’ˆ


```golang
var x1 = nil // wrong
var x2 interface{} = nil
var x3 string = nil // wrong
var x4 error = nil
```

### å †ï¼ˆheapï¼‰ï¼Œæ ˆï¼ˆstackï¼‰çš„åŒºåˆ«å’Œè”ç³»ï¼ˆğŸ˜… ğŸ˜… ğŸ˜… ï¼‰

### éå†mapé—®é¢˜

```golang
m := make(map[string]*Student)
stus := []Student{
    {Name: "zhao", Age: 23},
    {Name: "qian", Age: 23},
    {Name: "sun", Age: 23},
}
// å…¨éƒ½å–åˆ°ç›¸åŒçš„åœ°å€ï¼šmap[qian:0xc0000044c0 sun:0xc0000044c0 zhao:0xc0000044c0]
// for _, v := range stus {
// 	m[v.Name] = &v
// }
// map[qian:0xc000042068 sun:0xc000042080 zhao:0xc000042050]
for i := 0; i < len(stus); i++ {
    m[stus[i].Name] = &stus[i]
}
Println(m)
```


### sliceåˆå§‹åŒ–é—®é¢˜

```golang
s := make([]int, 5)
s = append(s, 1, 2, 3)
// [0 0 0 0 0 1 2 3]
Println(s)
```

### newåˆ‡ç‰‡è¿”å›æŒ‡é’ˆ

```golang
s := new([]int)
// first argument to append must be slice; have *[]int
s = append(s, 1)
Println(s)
```

### iotaç”¨æ³•

```golang
const (
	x = iota
	y
	z = "zz"
	k
	p = iota
)

func main() {
	// 0 1 zz zz 4
	Println(x, y, z, k, p)
}
```

### å¸¸é‡ä¸å…è®¸ä¿®æ”¹ï¼Œä¹Ÿä¸å…è®¸å–åœ°å€
```golang
const cl = 100

var bl = 123

func main() {
	Println(&bl, bl)
	// cannot take the address of cl
	Println(&cl, cl)
}
```

### ç±»å‹åˆ«åå’Œç±»å‹
```golang
type MyInt1 int
type MyInt2 = int // ğŸ˜… MyInt2å°±æ˜¯intç±»å‹
var i int = 9
// cannot use i (type int) as type MyInt1 in assignment
var i1 MyInt1 = i
var i2 MyInt2 = i
Println(i1, i2)
```

### å˜é‡ä½œç”¨åŸŸ

```golang
var ErrDidNotWork = errors.New("did not work")

func DoTheThing(reallyDoIt bool) (err error) {
	// å› ä¸º if è¯­å¥å—å†…çš„ err å˜é‡ä¼šé®ç½©å‡½æ•°ä½œç”¨åŸŸå†…çš„ err å˜é‡
	if reallyDoIt {
		result, err := tryTheThing()
		if err != nil || result != "it worked" {
			err = ErrDidNotWork
		}
	}
	return err
}
func tryTheThing() (string, error) {
	return "", ErrDidNotWork
}
func main() {
	// è¿”å› nil
	Println(DoTheThing(true))
	Println(DoTheThing(false))
}
```

### é—­åŒ…å»¶è¿Ÿæ±‚å€¼

```golang
func test() []func() {
	var funs []func()
	for i := 0; i < 2; i++ {
		funs = append(funs, func() {
			Println(&i, i)
		})
	}
	return funs
}

func main() {
    funs := test()
    // 0xc0000140a0 2
    // 0xc0000140a0 2
	for _, f := range funs {
		f()
	}
}
// è§£å†³é—­åŒ…å»¶è¿Ÿæ±‚å€¼é—®é¢˜
func test() []func() {
	var funs []func()
	for i := 0; i < 2; i++ {
		x := i
		funs = append(funs, func() {
			Println(&x, x)
		})
	}
	return funs
}
```

```golang
func test(x int) (func(), func()) {
	return func() {
			Println(x)
			x += 10
		}, func() {
			Println(x)
		}
}
func main() {
	a, b := test(100)
	a() // 100
	b() // 110
}
```