### 11.1 切片

切片（slice） 是对底层数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（和数组不一样）。切片提供对该数组中编号的元素序列的访问。 切片类型表示其元素类型的所有数组切片的集合。未初始化切片的值为nil

因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中切片比数组更常用。

声明切片的格式是： var identifier []type（不需要说明长度）。一个切片在未初始化之前默认为 nil，长度为 0。

切片初始化：

    var x = []int{2, 3, 5, 7, 11}
    var slice1 []type = make([]type, len,cap)
    v := make([]int, 10, 50)

    从数组或者切片中生成一个新的切片，我们可以使用下面的表达式：a[low : high : max] max-low的结果表示容量，high-low的结果表示长度
    a := [5]int{1, 2, 3, 4, 5}
    t := a[1:3:5]


### 11.2 切片重组

通过改变切片长度得到新切片的过程称之为切片重组 reslicing

在一个slice基础上重新划分一个slice时，新的slice会继续引用原有slice的数组。如果你忘了这个行为的话，在你的应用分配大量临时的slice用于创建新的slice来引用原有数据的一小部分时，会导致难以预期的内存使用。

```bash
func get() []byte {  
    raw := make([]byte, 10000)
    fmt.Println(len(raw), cap(raw), &raw[0]) // 显示: 10000 10000 数组首字节地址
    return raw[:3]  // 10000个字节实际只需要引用3个，其他空间浪费
}

func main() {  
    data := get()
    fmt.Println(len(data), cap(data), &data[0]) // 显示: 3 10000 数组首字节地址
}
```
为了避免这个陷阱，我们需要从临时的slice中使用内置函数copy()，拷贝数据（而不是重新划分slice）到新切片

```bash
func get() []byte {
    raw := make([]byte, 10000)
    fmt.Println(len(raw), cap(raw), &raw[0]) // 显示: 10000 10000 数组首字节地址
    res := make([]byte, 3)
    copy(res, raw[:3]) // 利用copy 函数复制，raw 可被GC释放
    return res
}

func main() {
    data := get()
    fmt.Println(len(data), cap(data), &data[0]) // 显示: 3 3 数组首字节地址
}
```

### 11.3 append操作

append()函数操作后，有没有生成新的slice需要看原有slice的容量是否足够

