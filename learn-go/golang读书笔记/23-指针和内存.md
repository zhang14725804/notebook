### 1.指针（todo：重难点）

指针的一个高级应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。指针传递是很廉价的，只占用 4 个或 8 个字节。

```go
    var a, b int = 20, 30 // 声明实际变量
    var ptra *int         // 声明指针变量
    var ptrb *int = &b

    ptra = &a // 指针变量的存储地址

    fmt.Printf("a  变量的地址是: %x\n", &a)
    fmt.Printf("b  变量的地址是: %x\n", &b)
    // a  变量的地址是: c00002c008
    // b  变量的地址是: c00002c040
    // 指针变量的存储地址
    fmt.Printf("ptra  变量的存储地址: %x\n", ptra)
    fmt.Printf("ptrb  变量的存储地址: %x\n", ptrb)
    // ptra  变量的存储地址: c00002c008
    // ptrb  变量的存储地址: c00002c040
    // 使用指针访问值
    fmt.Printf("*ptra  变量的值: %d\n", *ptra)
    fmt.Printf("*ptrb  变量的值: %d\n", *ptrb)
    // *ptra  变量的值: 20
    // *ptrb  变量的值: 30
    *ptra = 18
    fmt.Printf("*ptra  变量的值: %d\n", *ptra)
```

### 2.new和make（重难点）

- new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &T{}。

- make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel。


在Go中，即使是使用 new() 或者 make() 函数来分配，变量的位置还是由编译器决定。编译器根据变量的大小和泄露分析的结果来决定其位置。这也意味着在局部变量上返回引用是没问题的

### 3.垃圾回收和 SetFinalizer

Go 语言开发者一般不需要写代码来释放不再使用的变量或结构体占用的内存，在 Go语言运行时有一个独立的进程，即垃圾收集器（GC），会专门处理这些事情，它搜索不再使用的变量然后释放它们占用的内存，这是自动垃圾回收；还有一种是主动垃圾回收，通过显式调用 runtime.GC()来实现
