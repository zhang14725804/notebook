### 1.锁

Go语言包中的sync包提供了两种锁类型：sync.Mutex和sync.RWMutex，前者是**互斥锁**，后者是**读写锁**。

###  2.互斥锁

**互斥锁**是传统的并发程序对共享资源进行访问控制的主要手段，在Go中，似乎更推崇由channel来实现资源共享和通信。它由标准库代码包sync中的Mutex结构体类型代表。只有两个公开方法：调用Lock（）获得锁，调用unlock（）释放锁。

- Lock()加锁

使用Lock()加锁后，不能再继续对其加锁（同一个goroutine中，即：同步调用），否则会panic。只有在unlock()之后才能再次Lock()。异步调用Lock()，是正当的锁竞争，当然不会有panic了。适用于读写不确定场景，即读写次数没有明显的区别，并且只允许只有一个读或者写的场景，所以该锁也叫做全局锁。

- Unlock()用于解锁

func (m *Mutex) Unlock()用于解锁，如果在使用Unlock()前未加锁，就会引起一个运行错误。已经锁定的Mutex并不与特定的goroutine相关联，这样可以利用一个goroutine对其加锁，再利用其他goroutine对其解锁。

```go
var lck sync.Mutex
func foo() {
    lck.Lock() 
    defer lck.Unlock()
    // ...
}
```

### 3.读写锁

读写锁是分别针对读操作和写操作进行锁定和解锁操作的互斥锁。在Go语言中，读写锁由结构体类型sync.RWMutex代表。

RWMutex提供四个方法：
```go
    func (*RWMutex) Lock // 写锁定
    func (*RWMutex) Unlock // 写解锁

    func (*RWMutex) RLock // 读锁定
    func (*RWMutex) RUnlock // 读解锁

```

### 4.sync.WaitGroup

WaitGroup，它用于线程同步，WaitGroup等待一组线程集合完成，才会继续向下执行。 主线程(goroutine)调用Add来设置等待的线程(goroutine)数量。 然后每个线程(goroutine)运行，并在完成后调用Done。 同时，Wait用来阻塞，直到所有线程(goroutine)完成才会向下执行。Add(-1)和Done()效果一致。

### 5.sync.Once

sync.Once.Do(f func())能保证once只执行一次,这个sync.Once块只会执行一次。

### 6.sync.Map

sync.Map的使用上和map有较大差异