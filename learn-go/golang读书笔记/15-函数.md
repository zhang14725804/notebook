### 1.函数

函数调用传入的参数必须按照参数声明的顺序。而且Go语言没有默认参数值的说法。函数签名中的最后传入参数可以具有前缀为....的类型（...int），这样的参数称为可变参数，并且可以使用零个或多个参数来调用该函数，这样的函数称为变参函数。

    func doFix (prefix string, values ...int)


函数重载（function overloading）指的是可以编写多个同名函数，只要它们拥有不同的形参或者不同的返回值，在 Go 语言里面函数重载是不被允许的。

函数也可以作为函数类型被使用。函数类型也就是函数签名，函数类型表示具有相同参数和结果类型的所有函数的集合。函数类型的未初始化变量的值为nil

    type  funcType func (int, int) int // 通过type关键字，定义了一个新类型，函数类型 funcType 


函数也可以在表达式中赋值给变量，这样作为表达式中右值出现，我们称之为函数值字面量（function literal），函数值字面量是一种表达式，它的值被称为匿名函数

    f := func() int { return 7 }


```bash
type funcType func(time.Time)     // 定义函数类型funcType

func main() {
    f := func(t time.Time) time.Time { return t } // 方式一：直接赋值给变量
    fmt.Println(f(time.Now()))

    var timer funcType = CurrentTime // 方式二：定义函数类型funcType变量timer
    timer(time.Now())

    funcType(CurrentTime)(time.Now())  // 先把CurrentTime函数转为funcType类型，然后传入参数调用
// 这种处理方式在Go 中比较常见
}

func CurrentTime(start time.Time) {
    fmt.Println(start)
}
```

### 2.函数调用

Go 语言中函数默认使用按**值传递**来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量。

如果我们希望函数可以直接修改参数的值，而不是对参数的副本进行操作，则需要将参数的地址传递给函数，这就是按**引用传递**，比如 Function(&arg1)，此时传递给函数的是一个指针。如果传递给函数的是一个指针，我们可以通过这个指针来修改对应地址上的变量值。

命名返回值被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的return语句。需要注意的是，即使只有一个命名返回值，也需要使用 () 括起来

```bash
// 变参函数，参数不定长
func list(nums ...int) {
    fmt.Println(nums)
}

func main() {
    // 常规调用，参数可以多个
    list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    // 在参数同类型时，可以组成slice使用 parms... 进行参数传递
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    list(numbers...) // slice时使用
}
```

### 3.内置函数

    close
    new/make // todo：什么区别
    
    len
    cap

    append
    copy
    delete

    complex
    real
    imag

    panic
    recover

### 4.递归与回调

函数直接或间接调用函数本身，则该函数称为递归函数。使用递归函数时经常会遇到的一个重要问题就是栈溢出：一般出现在大量的递归调用导致的内存分配耗尽

### 5.匿名函数

### 6.函数闭包

闭包可被允许调用定义在其环境下的变量，可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。闭包继承了函数所声明时的作用域，作用域内的变量都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。也可以理解为**内层函数引用了外层函数中的变量或称为引用了自由变量**。

实质上看，闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。由闭包的实质含义，我们可以推论：**闭包获取捕获变量相当于引用传递，而非值传递**；对于闭包函数捕获的常量和变量，无论闭包何时何处被调用，闭包都可以使用这些常量和变量，而不用关心它们表面上的作用域。

### 7.变参函数

可变参数也就是不定长参数，支持可变参数列表的函数可以支持任意个传入参数