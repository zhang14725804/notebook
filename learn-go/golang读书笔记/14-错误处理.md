### 1.错误类型

    errors.New 
    fmt.Errorf

### 2.Panic

在Go语言中 panic 是一个内置函数，用来表示非常严重的不可恢复的错误。必须要先声明defer，否则不能捕获到panic异常。普通函数在执行的时候发生panic了，则开始运行defer（如有），defer处理完再返回。

在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 panicking。

标准库中有许多包含 Must 前缀的函数，像 regexp.MustComplie 和 template.Must；当正则表达式或模板中转入的转换字符串导致错误时，这些函数会 panic。

不能随意地用 panic 中止程序，必须尽力补救错误让程序能继续执行。

自定义包中的错误处理和 panicking，这是所有自定义包实现者应该遵守的最佳实践：

    1）在包内部，总是应该从 panic 中 recover：不允许显式的超出包范围的 panic()

    2）向包的调用者返回错误值（而不是 panic）。

recover() 的调用仅当它在 defer 函数中被直接调用时才有效。

### 3.Revover：从Panic中恢复

recover内建函数被用于从 panic 或 错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。 recover 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 recover 会返回 nil，且没有其它效果。 总结：panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止

```bash
func protect(g func()) {
    defer func() {
        log.Println("done")
        // 即使有panic，Println也正常执行。
        if err := recover(); err != nil {
            log.Printf("run time panic: %v", err)
        }
    }()
    log.Println("start")
    g() //   可能发生运行时错误的地方
}
```

### 4.Defer

- 规则一 当defer被声明时，其参数就会被实时解析
```bash
    var i int = 1

    defer fmt.Println("result =>", func() int { return i * 2 }())
    i++
    // 输出: result => 2 (而不是 4)
```
- 规则二 defer执行顺序为先进后出
```bash
    defer fmt.Print(" !!! ")
    defer fmt.Print(" world ")
    fmt.Print(" hello ")
```
- 规则三 defer可以读取有名返回值，也就是可以改变有名返回参数的值。（todo）

在Go语言中，return 语句不是原子操作，最先是所有结果值在进入函数时都会初始化为其类型的零值（姑且称为ret赋值），然后执行defer命令,最后才是return操作。如果是有名返回值，返回值变量其实可视为是引用赋值，可以能被defer修改。而在匿名返回值时，给ret的值相当于拷贝赋值，defer命令时不能直接修改。

### 5.计算函数执行时间

方法一：

    start := time.Now()
    longCalculation()
    end := time.Now()
    delta := end.Sub(start)

方法二，使用defer：

    func main(){
        defer timeCost(time.Now())
        fmt.Println("start program")
        time.Sleep(5*time.Second)
        fmt.Println("finish program")
    }

    func timeCost(start time.Time){
            terminal:=time.Since(start)
            fmt.Println(terminal)
    }