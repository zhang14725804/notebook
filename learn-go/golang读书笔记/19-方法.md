### 1.方法的定义 

在 Go 语言中，结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 语言中有一个概念，它和方法有着同样的名字，并且大体上意思相近。

Go 语言中方法和函数在形式上很像，它是作用在**接收器（receiver）**上的一个函数，接收器是某种类型的变量。因此方法是一种特殊类型的函数，方法只是比函数多了一个接收器（receiver），当然在接口中定义的函数我们也称为方法（因为最终还是要通过绑定到类型来实现）。

正是因为有了接收器，方法才可以作用于接收器的类型（变量）上，类似于面向对象中类的方法可以作用于类属性上。

- 方法重载

在Go语言中不允许方法重载，因为方法是函数，所以对于一个类型只能有唯一一个特定名称的方法。但是如果基于接收器类型，我们可以通过一种变通的方法，达到这个目的：具有同样名字的方法可以在 2 个或多个不同的接收器类型上存在，比如在同一个包里这么做是允许的：
```go
type MyInt1 int
type MyInt2 int

func (a *MyInt1) Add(b int) int { return 0 }
func (a *MyInt2) Add(b int) int { return 0 }
```

- 类型别名情况下方法是保留的，但自定义的新类型方法是需要重新定义的，原方法不保留

    type MyInt int // 自定义类型
    type NewInt = MyInt // 类型别名


### 2.指针方法和值方法区别

有类型T，方法的接收器为(t T)时我们称为值接收器，该方法称为值方法；方法的接收器为(t *T)时我们称为指针接收器，该方法称为指针方法。

如果想要方法改变接收器的数据，就在接收器的指针上定义该方法；否则，就在普通的值类型上定义方法。这是指针方法和值方法最大的区别。

```go
type T struct {
    Name string
}

func (t T) M1() {
    t.Name = "name1"
}
// 对于类型 T，如果在 *T 上存在方法 Meth()，并且 t 是这个类型的变量，那么 t.Meth() 会被自动转换为 (&t).Meth()。
// 无论你声明方法的接收器是指针接收器还是值接收器，Go都可以帮你隐式转换为正确的方法使用。
func (t *T) M2() {
    t.Name = "name2"
}
func main() {

    t1 := T{"t1"}

    fmt.Println("M1调用前：", t1.Name)
    t1.M1()
    fmt.Println("M1调用后：", t1.Name)

    fmt.Println("M2调用前：", t1.Name)
    t1.M2()
    fmt.Println("M2调用后：", t1.Name)

}

程序输出：
M1调用前： t1
M1调用后： t1
M2调用前： t1
M2调用后： name2

```

###  接口变量上的指针方法与值方法（todo:晕了😅）

```go
type T struct {
    Name string
}
type Intf interface {
    M1()
    M2()
}

func (t T) M1() {
    t.Name = "name1"
}

func (t *T) M2() {
    t.Name = "name2"
}
func main() {
    var t1 T = T{"t1"}
    t1.M1()
    t1.M2()

    var t2 Intf = t1
    t2.M1()
    t2.M2()
}
```

- 规则一：如果使用指针方法来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。
- 规则二：如果使用值方法来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。

```go
type T struct {
    Name string
}
type Intf interface {
    M1()
    M2()
}

func (t T) M1() {
    t.Name = "name1"
}

func (t *T) M2() {
    t.Name = "name2"
}
func main() {

    var t1 T = T{"t1"}
    t1.M1()
    t1.M2()

    var t2 Intf = &t1
    t2.M1()
    t2.M2()
}
```

### 3.匿名类型的方法提升（骚操作！）

当我们嵌入一个匿名类型，这个类型的方法就变成了外部类型的方法，但是当它的方法被调用时，方法的接收器是内部类型(嵌入的匿名类型)，而非外部类型。

- 规则一：如果S包含嵌入字段T，则S和*S的方法集都包括具有接收方T的提升方法。*S的方法集还包括具有接收方*T的提升方法。

- 规则二：如果S包含嵌入字段T，则S和\S的方法集都包括具有接收器T或*T的提升方法。

```go
type People struct {
    Age    int
    gender string
    Name   string
}

type OtherPeople struct {
    People
}

func (p People) PeInfo() {
    fmt.Println("People ", p.Name, ": ", p.Age, "岁, 性别:", p.gender)
}

// 因此嵌入类型的名字充当着字段名，同时嵌入类型作为内部类型存在
OtherPeople.People.PeInfo()

// 可以通过类型名称来访问内部类型的字段和方法。然而，这些字段和方法也同样被提升到了外部类型，我们可以直接访问
OtherPeople.PeInfo()

```