### 1.引言

互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock()和Unlock()分别用于加锁和解锁。

Mutex使用起来非常方便，但其内部实现却复杂得多，这包括Mutex的几种状态。另外，我们也想探究一下Mutex重复解锁引起panic的原因。

### 2.Mutex数据结构

2.1 Mutex结构体

```golang
    type Mutex struct {
        state int32 // 表示互斥锁的状态，比如是否被锁定等。
        sema  uint32 // 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。
    }
```

Mutex.state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态

    Locked: 表示该Mutex是否已被锁定，0：没有锁定 1：已被锁定。
    Woken: 表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。
    Starving：表示该Mutex是否处理饥饿状态， 0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过1ms。
    Waiter: 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。

2.2 Mutex方法

    Lock() : 加锁方法
    Unlock(): 解锁方法

3. 加锁过程（question）

4. 自旋过程（question）

5. Mutex模式（question）

后面越讲越凌乱了