## 哈希表

[go语言map实现](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/)

### 实现原理

想要实现一个性能优异的哈希表，需要注意两个关键点 —— 【哈希函数】和【冲突解决】方法。

### 哈希函数

在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求哈希函数的输出范围大于输入范围，但是由于键的数量会远远大于映射的范围

比较实际的方式是让哈希函数的结果能够尽可能的【均匀分布】，然后通过工程上的手段解决哈希碰撞的问题。哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。

### 冲突解决

【开放寻址法】和【拉链法】

需要注意的是，这里提到的哈希碰撞不是多个键对应的哈希完全相等，可能是多个哈希的【部分相等】，例如：两个键对应哈希的前四个字节相同。

- 开放寻址法

**依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中**，如果我们使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是【数组】

【写入数据】:当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置

【查找数据】:当需要查找某个键对应的值时，会从索引的位置开始线性探测数组，找到目标键值对或者空内存就意味着这一次查询操作的结束

开放寻址法中对性能影响最大的是【装载因子】，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 O(n) 的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。

- 拉链法

实现拉链法一般会使用【数组】加上【链表】，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成可以扩展的二维数组

【写入数据】先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式是直接对哈希返回的结果取模，找到键相同的键值对 — 更新键对应的值；没有找到键相同的键值对 — 在链表的末尾追加新的键值对；

【查找数据】先经过一个哈希函数，根据哈希找到一个桶，它会依次遍历桶中的链表


### golang中map数据结构 (🔥🔥🔥 复杂了！！！)

### 初始化（🔥🔥🔥 复杂了！！！）

### 读写操作（🔥🔥🔥 复杂了！！！）