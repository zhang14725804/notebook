## 内存分配原理

    堆栈 & 逃逸分析
    分段栈 & 连续栈
    内存结构（内存管理）
    优化实践

## 堆和栈的定义，【栈】和【堆】的区别

Go 有两个地方可以分配内存：（1）一个全局堆空间用来动态分配内存；（2）另一个是每个 goroutine 都有的自身栈空间。

### 逃逸分析

“通过检查变量的作用域是否超出了它所在的栈来决定是否将它分配在堆上”的技术，其中“变量的作用域超出了它所在的栈”这种行为即被称为【逃逸】。逃逸分析在大多数语言里属于静态分析：在编译期由静态代码分析来决定一个值是否能被分配在栈帧上，还是需要“逃逸”到堆上。


尽可能让变量在【栈】上，而不是在堆上

Go 查找所有变量超过当前函数栈侦的，把它们分配到堆上，避免 outlive 变量。

【逃逸案例】

    一个值被分享到函数栈帧范围之外
    在 for 循环外申明，在 for 循环内分配，同理闭包
    发送指针或者带有指针的值到 channel 中
    在一个切片上存储指针或带指针的值
    slice 的背后数组被重新分配了
    在 interface 类型上调用方法

go build -gcflags -m

## 连续栈

### 分段栈

Go 应用程序运行时，每个 goroutine 都维护着一个自己的栈区，这个栈区只能自己使用不能被其他 goroutine 使用。栈区的初始大小是2KB，在 goroutine 运行的时候栈区会按照需要增长和收缩。旧栈通过指针连接新栈，旧栈的内容原封不动，新数据存到新栈

【Hot split问题】：如果栈快满了，那么下一次的函数调用会强制触发栈扩容。当函数返回时，新分配的 “stack chunk” 会被清理掉

### 连续栈

采用复制栈的实现方式，会分配一个两倍大的内存块并把老的内存块内容复制到新的内存块里。

    （1）runtime.newstack 分配更大的栈内存空间
    （2）runtime.copystack 将旧栈中的内容复制到新栈中
    （3）将指向旧栈对应变量的指针重新指向新栈
    （4）runtime.stackfree 销毁并回收旧栈的内存空间


### 栈扩容（复杂 😅 ）

Go 运行时判断栈空间是否足够，所以在 call function 中会插入 runtime.morestack，但每个函数调用都判定的话，成本比较高。


## 内存管理（复杂 😅 ）

[图解TCMalloc](https://zhuanlan.zhihu.com/p/29216091)

Go的内存管理是借鉴了【TCMalloc】，主要解决两个问题：

    （1）内存碎片
    （2）大锁

Go的内存管理分为三类：

    小于 32kb 内存分配
    小于 16b 内存分配
    大于 32kb 内存分配

一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。核心是：【分级 + 减少大锁】

    Go 在程序启动时，会向操作系统申请一大块内存，由 mheap 结构全局管理(现在 Go 版本 不需要连续地址了，所以不会申请一大堆地址)
    Go 内存管理的基本单元是 mspan，每种 mspan 可以分配特定大小的 object
    mcache, mcentral, mheap 是 Go 内存管理的三大组件，mcache 管理线程在本地缓存的 mspan；mcentral 管理全局的 mspan 供所有线程


分配内存的过程：mcache(不需要加锁) -> mcentral(需要加锁) -> mheap