###Virtual DOM实现原理###

1、引言

在前端应用中，状态管理是一个经常被提及的话题，从早期的刀耕火种时代到jQuery，再到现在流行的MVVM时代。我们再也不用维护茫茫多的事件回调、监听来更新视图，转而使用使用双向数据绑定，只需要维护相应的数据状态，就可以自动更新视图

双向数据绑定也并不是唯一的办法，还有一个非常粗暴有效的方式：一旦数据发生变化，重新绘制整个视图，也就是重新设置一下innerHTML。这样的做法确实简单、粗暴、有效，但是如果只是因为局部一个小的数据发生变化而更新整个视图，性价比未免太低了，而且，像事件，获取焦点的输入框等，都需要重新处理。所以，对于小的应用或者说局部的小视图，这样处理完全是可以的，但是面对复杂的大型应用，这样的做法不可取

2、什么是Virtual DOM

- Virtual DOM是一个基本的JavaScript对象，也是整个Virtual DOM树的基本
- JavaScript很快和直接操作DOM很慢，这是Virtual DOM得以实现的两个基本前提。得益于V8引擎的出现，让JavaScript可以高效地运行，在性能上有了极大的提高。直接操作DOM的低效和JavaScript的高效相对比，为Virtual DOM的产生提供了大前提。
- Virtual DOM的三个重要步骤，分别是：**生成Virtual DOM树、对比两棵树的差异、更新视图**

3、生成Virtual DOM

抽象出一个DOM节点却只需要三部分：**节点类型，节点属性、子节点**。所以围绕这三个部分，我们可以使用JavaScript简单地实现一棵DOM树，然后给节点实现渲染方法，就可以实现虚拟节点到真是DOM的转化

4、对比两棵树的差异

比较两棵DOM树的差异是Virtual DOM算法最核心的部分，这也是我们常说的的 Virtual DOM的diff算法。在比较的过程中，我们只比较同级的节点，非同级的节点不在我们的比较范围内，这样既可以满足我们的需求，又可以简化算法实现

比较“树”的差异，首先是要对树进行遍历，常用的有两种遍历算法，分别是深度优先遍历和广度优先遍历，一般的diff算法中都采用的是深度优先遍历。对新旧两棵树进行一次深度优先的遍历，这样每个节点都会有一个唯一的标记。在遍历的时候，每遍历到一个节点就把该节点和新的树的同一个位置的节点进行对比，如果有差异的话就记录到一个对象里面

常见的差异包括四种，分别是：

- 替换节点
- 增加/删除子节点
- 修改节点属性
- 改变文本内容

所以在记录差异的时候要根据不同的差异类型，记录不同的内容

5、更新视图

得到整棵树的差异之后，就可以根据这些差异的不同类型，对DOM进行针对性的更新。与四种差异类型相对应的，是更新视图时具体的更新方法，分别是：

- replaceChild()
- appendChild()/removeChild()
- setAttribute()/removeAttribute()
- textContent

结论

**Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。这一点是原生操作远远无法替代的**

到此为止，再次审视Virtual DOM，可以简单得出如下结论：

- Virtual DOM 在牺牲部分性能的前提下，增加了可维护性，这也是很多框架的通性
- 实现了对DOM的集中化操作，在数据改变时先对虚拟DOM进行修改，再反映到真实的DOM中，用最小的代价来更新DOM，提高效率
- 打开了函数式UI编程的大门
- 可以渲染到DOM以外的端，比如ReactNative
